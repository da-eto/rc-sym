## Экспорт заведений

Приложение, которое выбирает все заведения и экспортирует их в XML, CSV, HTML.

### Установка и настройка

Для локальной настройки (например, БД) можно скопировать файл `.env` в `.env.local` и изменить переменные.

Запуск dev-среды:
```shell script
$ docker-compose up -d
``` 

Установка зависимостей:
```shell script
$ docker-compose exec php bash
root@docker-php:/var/www/html# cd /app
root@docker-php:/app# composer install
```

Все команды, начинающиеся с `root@docker-php`, выполняются в докер-контейнере php. При запуске на машине разработчика на этом месте будет приветствие вида `root@070b69e285a3` с ID контейнера.

Миграция БД:
```shell script
root@docker-php:/app# bin/console doctrine:migrations:migrate
```

### Запуск

Перед первоначальным запуском можно сгенерировать и загрузить фикстуры:
```shell script
root@docker-php:/app# bin/console doctrine:fixtures:load
```

Запуск импорта (например, в xml):
```shell script
root@docker-php:/app# bin/console app:export-places xml var/places.xml
```

### Добавление нового типа экспорта

Основные интерфейсы живут в `\App\Exporter\Places\`, далле все референсы относительно этого неймспейса.

Для добавления нового типа экспорта достаточно создать реализации `PlacesExporterFactoryInterface` и `PlacesExporterFormatterInterface`, имя класса с необходимым типом экспорта добавить в `PlacesExporter::EXPORTER_FACTORIES`. Форматеры легко тестировать. В сложных случаях можно реализовать свой `PlacesExporterWriterInterface` вместо использования готового `Writer\TextFileWriter`.

### Комментарии

Эта реализация далека от идеала. В частности:
 * Не уверен, нужен ли сервис-локатор для отдельных экспортов. Этот вариант выбран вместо автоматической регистрации через `_instanceof`, поскольку не инстанциирует все возможные экспорты и позволяет контролировать их включение/выключение через `PlacesExporter::EXPORTER_FACTORIES`. Возмжоно, стоит всё же использовать `_instanceof` и контроль за включением и именем типа перенести в сами экспорты.
 * Момент с выделенными `PlacesExporterWriterInterface` кажется оверинжинирингом. На примере экспорта в xml через `XMLWriter` заметил, что он рассчитан на потоковое использование и выдаёт конец шапки при записи информации о первом заведении. Подумал, что в случае бинарных или сложных форматов может быть такая же ситуация. Но этот момент можно обойти, использовав другой метод записи xml. Тогда достаточно будет оставить только форматеры.
 * Экспорт заточен под вывод в файлы, поскольку рассчитан на большое количество записей. По-хорошему, стоит работу с файлами хотя бы заменить на файловые ресурсы, их прокидывать внутрь, чтобы проще было тестировать. Или вообще упростить задачу и работать только со строками внутри, оставить одни форматеры (см. выше).
 * Выборку в репозитории можно заменить на iterable результат, под него сделать провайдер данных, а уже его передавать в экспорты. Возможно, для каких-то форматов понадобится отдельный список городов, его сделать так же. Тогда получится лучше разделить ответственность между классами.
